// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * Supplementary data structures
 */

/*
 * (c) 2014-2017 Vladimír Štill <xstill@fi.muni.cz>
 */

/* Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE. */

#include <map>
#include <vector>
#include <utility>
#include <type_traits>
#include <stdexcept>
#include <initializer_list>
#include <array>
#include <iterator>
#include <memory>

#include <brick-assert>

#ifndef BRICK_DATA_H
#define BRICK_DATA_H

namespace brick {
namespace t_data { struct TestIntervalSet; } /* forward declare for friend declarations */
namespace data {

template< typename K, typename V >
struct RMap : std::map< K, V > {

    template< typename... Args >
    RMap( Args &&...args ) : std::map< K, V >( std::forward< Args >( args )... ) { }

    using std::map< K, V >::operator[]; // non-const one
    const V &operator[]( const K &key ) const {
        return this->at( key );
    }
};

template< typename A, typename B > struct Bimap;

namespace _impl {

template< typename A, typename B >
struct BimapIx {

    B operator[]( const A &key ) const { return self().left()[ key ]; }
    A operator[]( const B &key ) const { return self().right()[ key ]; }

  private:
    const Bimap< A, B > &self() const {
        return *static_cast< const Bimap< A, B > * >( this );
    }
};

template< typename A >
struct BimapIx< A, A > { };

}

template< typename A, typename B >
struct Bimap : _impl::BimapIx< A, B > {
    using value_type = std::pair< const A, const B >;

    static_assert( std::is_same< value_type,
            typename std::map< A, const B >::value_type >::value,
            "value_type" );

    Bimap() = default;

    Bimap( std::initializer_list< value_type > init ) {
        for ( auto &p : init )
            insert( std::move( p ) );
    }

    template< typename Iterator >
    Bimap( Iterator begin, Iterator end ) {
        for ( ; begin != end; ++begin )
            insert( *begin );
    }

    const RMap< A, const B > &left() const { return _left; }
    const RMap< B, const A > &right() const { return _right; }

    bool insert( const value_type &value ) {
        return insert( value.first, value.second );
    }

    bool insert( const A &a, const B &b ) {
        auto l = _left.insert( { a, b } );
        auto r = _right.insert( { b, a } );
        if ( l.second != r.second ) {
            if ( l.second )
                _left.erase( l.first );
            else
                _right.erase( r.first );
            throw std::invalid_argument( "Bimap: Insert would break bijection" );
        }
        return l.second;
    }

  private:
    RMap< A, const B > _left;
    RMap< B, const A > _right;

    static std::pair< const B, const A > swap( const std::pair< const A, const B > &pair ) {
        return { pair.second, pair.first };
    }
    static std::pair< const B, const A > swap( std::pair< const A, const B > &&pair ) {
        return { std::move( pair.second ), std::move( pair.first ) };
    }
};

// a set for efficient storage of intervals [a, b) (i.e. from is inclusive,
// while to is exclusive)
template< typename T, typename Cmp = std::less< T > >
struct IntervalSet
{
    using value_type = std::pair< T, T >;
    using map = std::map< T, T, Cmp >;
    using iterator = typename map::const_iterator;
    using const_iterator = iterator;

    struct Inserted {
        Inserted( bool was_contained, bool had_intersection ) :
            was_contained( was_contained ), had_intersection( had_intersection )
        { }

        bool was_contained;
        bool had_intersection;
    };

    Inserted insert( value_type v ) {
        ASSERT( _less( v.first, v.second ) );

        typename map::iterator next = _map.upper_bound( v.first ),
                 prev = next == _map.begin() ? next : std::prev( next );
        if ( ( next == prev || _less( prev->second, v.first ))
                 && ( next == _map.end() || _less( v.second, next->first ) ) )
        {
            _map[ v.first ] = v.second;
            return { false, false };
        }

        if ( _subset( v, *prev ) )
            return { true, true };

        Inserted i = { false, false };
        if ( prev != next && _leq( v.first, prev->second ) )
            i.had_intersection = _less( v.first, prev->second );
        else
            prev = _map.insert( next, { v.first, next->second } );

        while ( next != _map.end() && _leq( next->first, v.second ) ) {
            i.had_intersection |= _less( next->first, v.second );
            prev->second = next->second;
            _map.erase( next++ );
        }
        if ( _less( prev->second, v.second ) )
            prev->second = v.second;
        return i;
    }

    Inserted insert( T first, T second ) { return insert( { first, second } ); }

    const_iterator find( T val ) const {
        auto it = _map.upper_bound( val );
        if ( it == _map.begin() )
            return _map.end();
        --it;
        if ( _less( it->second, val ) )
            return _map.end();
        return it;
    }

    size_t count( T val ) const {
        return find( val ) != _map.end();
    }

    bool empty() const { return _map.empty(); }
    size_t size() const { return _map.size(); }

    void clear() { _map.clear(); }

    const_iterator begin() const { return _map.begin(); }
    const_iterator cbegin() const { return _map.begin(); }

    const_iterator end() const { return _map.end(); }
    const_iterator cend() const { return _map.end(); }

  private:
    friend struct brick::t_data::TestIntervalSet;

    map _map;

    void _validate() {
        bool prevSet = false;
        T prev;
        for ( const auto &p : _map ) {
            ASSERT( _less( p.first, p.second ) );
            ASSERT( !prevSet || _less( prev, p.first ) );
            prev = p.second;
            prevSet = true;
        }
    }

    static bool _less( const T &a, const T &b ) {
        return Cmp()( a, b );
    }

    static bool _eq( const T &a, const T &b ) {
        return !_less( a, b ) && !_less( b, a );
    }

    static bool _geq( const T &a, const T &b ) {
        return !_less( a, b );
    }

    static bool _leq( const T &a, const T &b ) {
        return _geq( b, a );
    }

    static bool _subset( const value_type &a, const value_type &b ) {
        return _geq( a.first, b.first ) && _leq( a.second, b.second );
    }
};

namespace uninitialized {
    template< typename InputIt, typename ForwardIt >
    ForwardIt move( InputIt first, InputIt last, ForwardIt dst ) {
        using T = typename std::iterator_traits< ForwardIt >::value_type;
        ForwardIt current = dst;
        try {
            for ( ; first != last; ++first, ++current )
                new ( static_cast< void * >( &*current ) ) T( *first );
            return current;
        } catch ( ... ) {
            for ( ; dst != current; ++dst )
                dst->~T();
            throw;
        }
    }

    template< typename T, typename ForwardIt >
    void construct( ForwardIt first, ForwardIt last )
    {
        ForwardIt current = first;
        try {
            for ( ; current != last; ++current )
                new ( static_cast< void * >( &*current ) ) T();
        } catch ( ... ) {
            for ( ; first != current; ++first )
                first->~T();
            throw;
        }
    }
}

template< typename T, int stackCapacity = (4 > (2 * sizeof( void * )) / sizeof( T ))
                                            ? 4 : (2 * sizeof( void * )) / sizeof( T ) >
struct SmallVector {
    SmallVector() : _sos( 0 ) {
        _onstack = true;
    }

    template< typename InputIt >
    SmallVector( InputIt begin, InputIt end ) : SmallVector() {
        _resize( std::distance( begin, end ) );
        std::uninitialized_copy( begin, end, this->begin() );
    }

    SmallVector( std::initializer_list< T > init ) : SmallVector() {
        _resize( init.size() );
        uninitialized::move( init.begin(), init.end(), begin() );
    }

    SmallVector( const SmallVector &other ) : SmallVector() {
        _resize( other._size );
        std::uninitialized_copy( other.begin(), other.end(), begin() );
    }

    SmallVector( SmallVector &&other ) noexcept : SmallVector() {
        if ( other._onstack ) {
            _resize( other._size );
            uninitialized::move( other.begin(), other.end(), begin() );
            other.resize( 0 );
        } else {
            _data.range = other._data.range;
            _size = other._size;
            _onstack = false;
            other._size = 0;
            other._onstack = true;
        }
    }

    ~SmallVector() {
        _drop< T >( begin(), end() );
        if ( !_onstack )
            operator delete( _data.range.begin );
    }

    SmallVector &operator=( const SmallVector &other )
    {
        _resize( other._size );
        std::uninitialized_copy( other.begin(), other.end(), begin() );
        return *this;
    }

    SmallVector &operator=( SmallVector &&other ) noexcept {
        std::swap( _data, other._data );
        std::swap( _sos, other._sos );
        return *this;
    }

    T *begin() { return _onstack ? _data.data : _data.range.begin; }
    const T *begin() const { return _onstack ? _data.data : _data.range.begin; }
    const T *cbegin() const { return begin(); }
    T &front() { return begin()[ 0 ]; }
    const T &front() const { return begin()[ 0 ]; }

    T *end() { return begin() + _size; }
    const T *end() const { return begin() + _size; }
    const T *cend() const { return begin() + _size; }
    T &back() { return end()[ -1 ]; }
    const T &back() const { return end()[ -1 ]; }

    T *data() { return begin(); }
    const T *data() const { return begin(); }

    long size() const { return _size; }
    long empty() const { return _size == 0; }

    long capacity() const {
        return _onstack ? stackCapacity : _data.range.capacity;
    }

    T &operator[]( long ix ) { return begin()[ ix ]; }
    const T &operator[]( long ix ) const { return begin()[ ix ]; }

    template< typename... Args >
    void emplace_back( Args&&... args ) {
        _resize( _size + 1 );
        new ( end() - 1 ) T( std::forward< Args >( args )... );
    }

    void push_back( const T &value ) { emplace_back( value ); }
    void pop_back() { _resize( _size - 1 ); }

    void resize( long count ) {
        long old = _size;
        _resize( count );
        auto from = begin() + old;
        auto to = end();
        if ( from < to )
            uninitialized::construct< T >( from, to );
    }

    void resize( long count, const T &value ) {
        long old = _size;
        _resize( count );
        auto from = begin() + old;
        auto to = end();
        if ( from < to )
            std::uninitialized_fill( from, to, value );
    }

    void reserve( long newcap ) {
        if ( newcap > capacity() )
            _reserve( newcap );
    }

    void clear() { _resize( 0 ); }
    void clear_and_drop_memory() {
        clear();
        if ( !_onstack ) {
            operator delete( _data.range.begin );
            _data.range.begin = nullptr;
            _onstack = true;
        }
    }

  private:

    struct Range {
        T *begin;
        long capacity;
    };
    union Data {
        Range range;
        T data[ stackCapacity ];
        Data() { }
        ~Data() { }
    };

    Data _data;
    union {
        struct {
            unsigned long _size : sizeof( unsigned long ) * 8 - 1;
            bool _onstack : 1;
        };
        unsigned long _sos;
    };

    template< typename X >
    auto _drop( X *, X * ) ->
        typename std::enable_if< std::is_trivially_destructible< X >::value >::type
    { }

    template< typename X >
    auto _drop( X *from, X *to ) ->
        typename std::enable_if< !std::is_trivially_destructible< X >::value >::type
    {
        for ( ; from < to; ++from )
            from->~X();
    }

    struct MemDeleter { void operator()( T *x ) { operator delete( x ); } };

    void _reserve( long count ) {
        if ( count < long( _size ) )
            _drop< T >( begin() + count, end() );
        else if ( count > capacity() ) {
            long newcap = 1;
            for ( ; newcap < count; newcap <<= 1 ) { }
            std::unique_ptr< T, MemDeleter > nstor(
                    static_cast< T * >( operator new( sizeof( T ) * newcap ) ) );
            uninitialized::move( begin(), end(), nstor.get() );
            _drop< T >( begin(), end() );
            if ( !_onstack )
                operator delete( _data.range.begin );
            _data.range.begin = nstor.release();
            _data.range.capacity = newcap;
            _onstack = false;
        }
    }

    void _resize( long count ) {
        _reserve( count );
        _size = count;
    }
};

}

namespace t_data {

using namespace brick::data;

#define TC( X ) do { try { X; } catch ( std::out_of_range &ex ) { \
        throw std::runtime_error( "caught: " + std::string( ex.what() ) + \
                " at " __FILE__ ":" + std::to_string( __LINE__ ) + \
                " while evaluating " + #X ); \
        } \
    } while ( false )
struct BimapTest {
    TEST(basic) {
        Bimap< int, int > a;
        Bimap< int, long > b;

        a.insert( 1, 42 );
        b.insert( 1, 42 );

        Bimap< int, int > ac( a );
        Bimap< int, long > bc( b );

        Bimap< int, int > am( std::move( a ) );
        Bimap< int, long > bm( std::move( b ) );

        TC( ASSERT_EQ( am.left()[ 1 ], 42L ) );
        TC( ASSERT_EQ( am.right()[ 42 ], 1 ) );
        TC( ASSERT_EQ( bm.left()[ 1 ], 42L ) );
        TC( ASSERT_EQ( bm.right()[ 42 ], 1 ) );

        Bimap< int, int > ai{ { 1, 42 }, { 2, 3 } };
        Bimap< int, long > bi{ { 1, 42 }, { 2, 3 } };

        TC( ASSERT_EQ( ai.left()[ 1 ], 42L ) );
        TC( ASSERT_EQ( ai.right()[ 42 ], 1 ) );
        TC( ASSERT_EQ( ai.left()[ 2 ], 3L ) );
        TC( ASSERT_EQ( ai.right()[ 3 ], 2 ) );

        TC( ASSERT_EQ( bi[ 1 ], 42L ) );
        TC( ASSERT_EQ( bi[ 42L ], 1 ) );
        TC( ASSERT_EQ( bi[ 2 ], 3L ) );
        TC( ASSERT_EQ( bi[ 3L ], 2 ) );

        Bimap< int, int > ait( ac.left().begin(), ac.left().end() );
        Bimap< int, long > bit( bc.left().begin(), bc.left().end() );

        TC( ASSERT_EQ( ait.left()[ 1 ], 42L ) );
        TC( ASSERT_EQ( ait.right()[ 42 ], 1 ) );
        TC( ASSERT_EQ( bit[ 1 ], 42L ) );
        TC( ASSERT_EQ( bit[ 42L ], 1 ) );
    }

    TEST(outOfRange) {
        Bimap< int, long > bim{ { 1, 42 } };
        TC( bim[ 42L ] );
        TC( bim[ 1 ] );
        try {
            bim[ 42 ];
            ASSERT( false );
        } catch ( std::out_of_range & ) { }
        try {
            bim[ 1L ];
            ASSERT( false );
        } catch ( std::out_of_range & ) { }
    }

    TEST(bijection) {
        Bimap< int, long > bim;
        bim.insert( 1, 42 );
        try {
            ASSERT( bim.insert( 1, 1 ) && false );
        } catch ( std::invalid_argument & ) { }
        ASSERT_EQ( bim.left().size(), 1ul );
        ASSERT_EQ( bim.right().size(), 1ul );
        try {
            ASSERT( bim.insert( 2, 42 ) && false );
        } catch ( std::invalid_argument & ) { }
        ASSERT_EQ( bim.left().size(), 1ul );
        ASSERT_EQ( bim.right().size(), 1ul );
    }

    TEST(bijection_ctor) {
        try {
            Bimap< int, int > bim{ { 1, 1 }, { 1, 42 } };
            ASSERT( false );
        } catch ( std::invalid_argument & ) { }
        try {
            Bimap< int, int > bim{ { 2, 42 }, { 1, 42 } };
            ASSERT( false );
        } catch ( std::invalid_argument & ) { }
    }
};

struct TestIntervalSet {

    TEST(disjoint_insert) {
        IntervalSet< int > set;
        ASSERT( set.empty() );
        ASSERT_EQ( set.size(), 0 );
        set._validate();

        auto i = set.insert( 0, 1 );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 1 );
        set._validate();

        // before
        i = set.insert( -10, -8 );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 2 );
        set._validate();

        // after
        i = set.insert( 8, 12 );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 3 );
        set._validate();

        // inbetween
        i = set.insert( 3, 5 );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 4 );
        set._validate();

        // close to, but not overlaping
        i = set.insert( -7, -6 );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 5 );
        set._validate();

        // close to, but not overlaping
        i = set.insert( -3, -1 );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 6 );
        set._validate();

        // close to end
        i = set.insert( 13, 15 );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 7 );
        set._validate();
    }

    TEST(overlap_inserts) {
        IntervalSet< int > set;
        ASSERT( set.empty() );
        ASSERT_EQ( set.size(), 0 );
        set._validate();

        // no overlap
        auto i = set.insert( 4, 8 );
        ASSERT( !set.empty() );
        ASSERT_EQ( set.size(), 1 );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        set._validate();
        ASSERT_EQ( set.find( 5 )->first, 4 );
        ASSERT_EQ( set.find( 5 )->second, 8 );

        // no overlap, after end
        i = set.insert( 32, 35 );
        ASSERT( !set.empty() );
        ASSERT_EQ( set.size(), 2 );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        set._validate();
        ASSERT_EQ( set.find( 34 )->first, 32 );
        ASSERT_EQ( set.find( 34 )->second, 35 );

        // overlaps with end
        i = set.insert( 5, 10 );
        ASSERT( !set.empty() );
        ASSERT( i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 2 );
        set._validate();
        ASSERT_EQ( set.find( 5 )->first, 4 );
        ASSERT_EQ( set.find( 5 )->second, 10 );

        // subset
        i = set.insert( 5, 8 );
        ASSERT( !set.empty() );
        ASSERT( i.had_intersection );
        ASSERT( i.was_contained );
        ASSERT_EQ( set.size(), 2 );
        set._validate();
        ASSERT_EQ( set.find( 5 )->first, 4 );
        ASSERT_EQ( set.find( 5 )->second, 10 );

        // the same
        i = set.insert( 4, 10 );
        ASSERT( !set.empty() );
        ASSERT( i.had_intersection );
        ASSERT( i.was_contained );
        ASSERT_EQ( set.size(), 2 );
        set._validate();
        ASSERT_EQ( set.find( 5 )->first, 4 );
        ASSERT_EQ( set.find( 5 )->second, 10 );

        // overlaps with begin
        i = set.insert( 30, 35 );
        ASSERT( !set.empty() );
        ASSERT( i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 2 );
        set._validate();
        ASSERT_EQ( set.find( 34 )->first, 30 );
        ASSERT_EQ( set.find( 34 )->second, 35 );

        // right after end
        i = set.insert( 10, 12 );
        ASSERT( !set.empty() );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 2 );
        set._validate();
        ASSERT_EQ( set.find( 5 )->first, 4 );
        ASSERT_EQ( set.find( 5 )->second, 12 );

        // right before end
        i = set.insert( 25, 30 );
        ASSERT( !set.empty() );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 2 );
        set._validate();
        ASSERT_EQ( set.find( 34 )->first, 25 );
        ASSERT_EQ( set.find( 34 )->second, 35 );

        // inbetween
        i = set.insert( 15, 20 );
        ASSERT( !set.empty() );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 3 );
        set._validate();
        ASSERT_EQ( set.find( 16 )->first, 15 );
        ASSERT_EQ( set.find( 16 )->second, 20 );

        // two sided overlap
        i = set.insert( 10, 16 );
        ASSERT( !set.empty() );
        ASSERT( i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 2 );
        set._validate();
        ASSERT_EQ( set.find( 16 )->first, 4 );
        ASSERT_EQ( set.find( 16 )->second, 20);

        // right inbetween
        i = set.insert( 20, 25 );
        ASSERT( !set.empty() );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 1 );
        set._validate();
        ASSERT_EQ( set.find( 16 )->first, 4 );
        ASSERT_EQ( set.find( 16 )->second, 35 );

        // no overlap, before fisrt
        i = set.insert( -5, -2 );
        ASSERT( !set.empty() );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.size(), 2 );
        set._validate();

        // spanning multiple succeeding with start overlap
        set.insert( 40, 45 );
        set.insert( 50, 55 );
        set.insert( 60, 65 );
        ASSERT_EQ( set.size(), 5 );
        i = set.insert( 30, 70 );
        ASSERT_EQ( set.size(), 2 );
        ASSERT( !set.empty() );
        ASSERT( i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.find( 16 )->first, 4 );
        ASSERT_EQ( set.find( 16 )->second, 70 );
        set._validate();

        // spanning multiple succeeding without start overlap
        set.insert( 80, 85 );
        set.insert( 90, 95 );
        set.insert( 100, 105 );
        ASSERT_EQ( set.size(), 5 );
        i = set.insert( 75, 102 );
        ASSERT_EQ( set.size(), 3 );
        ASSERT( !set.empty() );
        ASSERT( i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.find( 80 )->first, 75 );
        ASSERT_EQ( set.find( 80 )->second, 105 );
        set._validate();

        // the same but the inserted subsumes all in between and adds to them
        i = set.insert( 2, 110 );
        ASSERT_EQ( set.size(), 2 );
        ASSERT( !set.empty() );
        ASSERT( i.had_intersection );
        ASSERT( !i.was_contained );
        ASSERT_EQ( set.find( 80 )->first, 2 );
        ASSERT_EQ( set.find( 80 )->second, 110 );
        set._validate();
    }

    auto overlap_start() {
        IntervalSet< int > set;
        ASSERT( set.empty() );
        ASSERT_EQ( set.size(), 0 );
        set._validate();

        auto i = set.insert( 4, 8 );
        ASSERT( !set.empty() );
        ASSERT_EQ( set.size(), 1 );
        ASSERT( !i.had_intersection );
        ASSERT( !i.was_contained );
        set._validate();
        ASSERT_EQ( set.find( 5 )->first, 4 );
        ASSERT_EQ( set.find( 5 )->second, 8 );
        return set;
    }

    TEST(overlap_second_insert_back_subset) {
        auto set = overlap_start();

        auto i = set.insert( 4, 12 );
        ASSERT( !set.empty() );
        ASSERT_EQ( set.size(), 1 );
        ASSERT( i.had_intersection );
        ASSERT( !i.was_contained );
        set._validate();
        ASSERT_EQ( set.find( 5 )->first, 4 );
        ASSERT_EQ( set.find( 5 )->second, 12 );
    }

    TEST(overlap_second_insert_back_nosubset) {
        auto set = overlap_start();

        auto i = set.insert( 6, 12 );
        ASSERT( !set.empty() );
        ASSERT_EQ( set.size(), 1 );
        ASSERT( i.had_intersection );
        ASSERT( !i.was_contained );
        set._validate();
        ASSERT_EQ( set.find( 5 )->first, 4 );
        ASSERT_EQ( set.find( 5 )->second, 12 );
    }

    TEST(overlap_second_insert_front_subset) {
        auto set = overlap_start();

        auto i = set.insert( 0, 8 );
        ASSERT( !set.empty() );
        ASSERT_EQ( set.size(), 1 );
        ASSERT( i.had_intersection );
        ASSERT( !i.was_contained );
        set._validate();
        ASSERT_EQ( set.find( 5 )->first, 0 );
        ASSERT_EQ( set.find( 5 )->second, 8 );
    }

    TEST(overlap_second_insert_front_nosubset) {
        auto set = overlap_start();

        auto i = set.insert( 0, 6 );
        ASSERT( !set.empty() );
        ASSERT_EQ( set.size(), 1 );
        ASSERT( i.had_intersection );
        ASSERT( !i.was_contained );
        set._validate();
        ASSERT_EQ( set.find( 5 )->first, 0 );
        ASSERT_EQ( set.find( 5 )->second, 8 );
    }
};

struct TestSmallVector {

    struct A {
        A( int &v ) : v( &v ) {
            v = 1;
        }
        ~A() {
            *v = 2;
        }
        int *v;
    };

    TEST(basic) {
        SmallVector< long > vec_l;
        vec_l.emplace_back( 1 );
        ASSERT_EQ( vec_l[ 0 ], 1 );
        vec_l.emplace_back( 2 );
        ASSERT_EQ( vec_l[ 1 ], 2 );
        vec_l.emplace_back( 3 ); vec_l.emplace_back( 4 ); vec_l.emplace_back( 5 );
        ASSERT_EQ( vec_l[ 4 ], 5 );
        ASSERT_EQ( vec_l.end()[ -1 ], 5 );
        SmallVector< int > vec_i;
        for ( int i = 1; i < 128; ++i ) {
            vec_i.emplace_back( i );
            ASSERT_EQ( i, vec_i.size() );
            ASSERT_LEQ( i, vec_i.capacity() );
        }
        int v = 0;
        {
            SmallVector< A > vec_a;
            vec_a.emplace_back( v );
            ASSERT_EQ( v, 1 );
        }
        ASSERT_EQ( v, 2 );
    }

    TEST(resize) {
        SmallVector< int, 8 > vec;
        ASSERT_EQ( vec.capacity(), 8 );
        ASSERT_EQ( vec.size(), 0 );
        vec.resize( 14 );
        ASSERT_EQ( vec.capacity(), 16 );
        ASSERT_EQ( vec.size(), 14 );
        vec.resize( 200 );
        ASSERT_EQ( vec.capacity(), 256 );
        ASSERT_EQ( vec.size(), 200 );
        vec.resize( 512 );
        ASSERT_EQ( vec.capacity(), 512 );
        ASSERT_EQ( vec.size(), 512 );
        vec.resize( 16 );
        ASSERT_EQ( vec.capacity(), 512 );
        ASSERT_EQ( vec.size(), 16 );
        vec[ 0 ] = 42;
        vec.resize( 1 );
        ASSERT_EQ( vec.capacity(), 512 );
        ASSERT_EQ( vec.size(), 1 );
        ASSERT_EQ( vec[ 0 ], 42 );
        vec.resize( 0 );
        ASSERT_EQ( vec.capacity(), 512 );
        ASSERT_EQ( vec.size(), 0 );
    }

    struct Tracker {
        Tracker( int &cnt ) : _cnt( &cnt ) { ++(*_cnt); }
        Tracker( const Tracker &o ) : _cnt( o._cnt ) { ++(*_cnt); }
        ~Tracker() { --(*_cnt); }
        int *_cnt;
    };

    TEST(resize_copy) {
        SmallVector< Tracker, 4 > vec;
        int cnt = 0;
        vec.resize( 16, Tracker( cnt ) );
        ASSERT_EQ( vec.size(), 16 );
        ASSERT_EQ( vec.capacity(), 16 );
        ASSERT_EQ( cnt, 16 );
        vec.resize( 24, Tracker( cnt ) );
        ASSERT_EQ( vec.size(), 24 );
        ASSERT_EQ( vec.capacity(), 32 );
        ASSERT_EQ( cnt, 24 );
        vec.resize( 8, Tracker( cnt ) );
        ASSERT_EQ( vec.size(), 8 );
        ASSERT_EQ( vec.capacity(), 32 );
        ASSERT_EQ( cnt, 8 );
        vec.clear();
        ASSERT_EQ( vec.size(), 0 );
        ASSERT_EQ( vec.capacity(), 32 );
        ASSERT_EQ( cnt, 0 );
        vec.clear_and_drop_memory();
        ASSERT_EQ( vec.size(), 0 );
        ASSERT_EQ( vec.capacity(), 4 );
        vec.resize( 2, Tracker( cnt ) );
        ASSERT_EQ( vec.size(), 2 );
        ASSERT_EQ( vec.capacity(), 4 );
        ASSERT_EQ( cnt, 2 );
        vec.clear_and_drop_memory();
        ASSERT_EQ( vec.size(), 0 );
        ASSERT_EQ( vec.capacity(), 4 );
    }

    TEST(reserve) {
        SmallVector< int, 8 > vec;
        ASSERT_EQ( vec.capacity(), 8 );
        ASSERT_EQ( vec.size(), 0 );
        vec.reserve( 14 );
        ASSERT_EQ( vec.capacity(), 16 );
        ASSERT_EQ( vec.size(), 0 );
        vec.reserve( 200 );
        ASSERT_EQ( vec.capacity(), 256 );
        ASSERT_EQ( vec.size(), 0 );
        vec.reserve( 512 );
        ASSERT_EQ( vec.capacity(), 512 );
        ASSERT_EQ( vec.size(), 0 );
        vec.reserve( 16 );
        ASSERT_EQ( vec.capacity(), 512 );
        ASSERT_EQ( vec.size(), 0 );
        vec.reserve( 0 );
        ASSERT_EQ( vec.capacity(), 512 );
        ASSERT_EQ( vec.size(), 0 );
    }

    template< int def > struct Int {
        Int( int i ) : v( i ) { }
        Int() : v( def ) { }
        ~Int() { v = 0; }
        operator int() { return v; }
        volatile int v;
    };

    TEST(defcon) {
        SmallVector< Int< 42 >, 8 > vec;
        std::fill( vec.data(), vec.data() + 8, 0 );

        vec.resize( 4 );
        for ( int i = 0; i < 4; ++i )
            ASSERT_EQ( int( vec[ i ] ), 42 );
        for ( int i = 4; i < 8; ++i )
            ASSERT_EQ( int( vec[ i ] ), 0 );

        vec.resize( 16 );
        for ( int i = 0; i < 16; ++i )
            ASSERT_EQ( int( vec[ i ] ), 42 );

        vec.resize( 8 );
        for ( int i = 0; i < 8; ++i )
            ASSERT_EQ( int( vec[ i ] ), 42 );
        for ( int i = 8; i < 16; ++i )
            ASSERT_EQ( int( vec[ i ] ), 0 );

        vec.clear();
        for ( int i = 0; i < 16; ++i )
            ASSERT_EQ( int( vec[ i ] ), 0 );
    }

    TEST(push) {
        SmallVector< int > vec;
        for ( int i = 0; i < 512; ++i ) {
            vec.emplace_back( i );
            ASSERT_EQ( vec.back(), i );
            ASSERT_EQ( vec.size(), i + 1 );
            ASSERT_LEQ( i + 1, vec.capacity() );
        }
        for ( int i = 511; i >= 256; --i ) {
            ASSERT_EQ( vec.back(), i );
            vec.pop_back();
            ASSERT_EQ( vec.size(), i );
            ASSERT_EQ( vec.capacity(), 512 );
        }
        for ( int i = 256; i < 512; ++i ) {
            vec.emplace_back( i );
            ASSERT_EQ( vec.back(), i );
            ASSERT_EQ( vec.size(), i + 1 );
            ASSERT_EQ( vec.capacity(), 512 );
        }
        for ( int i = 0; i < 512; ++i )
            ASSERT_EQ( vec[ i ], i );
        ASSERT_EQ( vec.size(), 512 );
        ASSERT_EQ( vec.capacity(), 512 );
        while ( !vec.empty() ) {
            ASSERT_LEQ( 1, vec.size() );
            vec.pop_back();
            ASSERT_LEQ( 0, vec.size() );
        }
        ASSERT_EQ( 0, vec.size() );
    }

    TEST(move) {
        // when on stack, vector has to move elements around
        SmallVector< int, 2 > x{ 1, 2 };
        int *px = &x[ 0 ], *py, *pz;
        SmallVector< int, 2 > y = std::move( x );
        ASSERT_NEQ( px, (py = &y[ 0 ]) ); // on stack
        x = std::move( y );
        ASSERT_EQ( px, &x[ 0 ] );
        ASSERT_NEQ( px, py );

        x.push_back( 3 ); // move it out of stack, now move should preserve references
        ASSERT_NEQ( px, &x[ 0 ] );
        px = &x[ 0 ];
        SmallVector< int, 2 > z( std::move( x ) );
        pz = &z[ 0 ];
        ASSERT_EQ( px, pz );
        y = std::move( z );
        ASSERT_NEQ( py, &y[ 0 ] );
        py = &y[ 0 ];
        ASSERT_EQ( pz, py );
    }
};

#undef TC
}
}

#endif // BRICK_DATA_H

// vim: syntax=cpp tabstop=4 shiftwidth=4 expandtab
