// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * (c) 2017 Vladimír Štill
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef DIVINE_RELAX_WARNINGS
DIVINE_RELAX_WARNINGS
#endif

#include <llvm/Support/YAMLParser.h>
#include <llvm/Support/YAMLTraits.h>

#ifdef DIVINE_RELAX_WARNINGS
DIVINE_UNRELAX_WARNINGS
#endif

#include <deque>
#include <type_traits>

namespace brick {
namespace yaml {

namespace lyaml = ::llvm::yaml;
using ::llvm::dyn_cast;
using ::llvm::cast;
using ::llvm::isa;

struct Parser
{
    using KeyList = std::deque< std::string >;

    Parser( std::string data ) :
        _data( std::move( data ) )
    { }

    template< typename T, typename Fail >
    void getF( KeyList done, KeyList todo, Fail fail, T &result, lyaml::Node *node )
    {
        if ( todo.empty() )
            return extractValue( result, node, fail );

        auto key = todo.front();
        todo.pop_front();
        done.push_back( key );
        ASSERT( node );

        if ( key == "*" ) /* collect items from a sequence */
        {
            auto *seq = dyn_cast< lyaml::SequenceNode >( node );
            if ( !seq )
                return fail( result, "YAML error: not a sequence node", done, todo );
            for ( auto &sub : *seq )
                getF( done, todo, fail, result, &sub );
            return;
        }

        auto *map = dyn_cast< lyaml::MappingNode >( node );
        if ( !map )
            return fail( result, "YAML error: not an object node", done, todo );

        bool found = false;

        for ( auto &pair : *map )
        {
            if ( auto *skey = dyn_cast< lyaml::ScalarNode >( pair.getKey() ) )
            {
                ::llvm::SmallVector< char, 128 > storage;
                auto ref = skey->getValue( storage );
                if ( ref == key )
                    getF( done, todo, fail, result, pair.getValue() ), found = true;
            }
        }

        if ( !found )
            return fail( result, "YAML error: key not found: " + key, todo, done  );
    }

    template< typename T, typename Fail >
    T getF( KeyList keys, Fail fail )
    {
        ::llvm::SourceMgr smgr;
        lyaml::Stream input( _data, smgr );
        T result;

        if ( input.failed() )
            return fail( result, "YAML input failed", keys, KeyList{} ), result;
        // begin can be called only once
        auto beg = input.begin(),
             end = input.end();
        if ( beg == end )
            return fail( result, "YAML input empty", keys, KeyList{} ), result;

        getF( {}, keys, fail, result, beg->getRoot() );
        return result;
    }

    template< typename T >
    T getOr( KeyList keys, T def )
    {
        return getF< T >( std::move( keys ), [&]( T &r, auto &&... ) { r = def; } );
    }

    template< typename T >
    T get( KeyList keys )
    {
        return getF< T >( std::move( keys ),
                          [&]( T &, const std::string &msg, KeyList next, KeyList seen )
                          {
                              std::stringstream ss;
                              ss << msg << std::endl << "found key trace: ";
                              for ( auto &k : seen )
                                  ss << k << ", ";
                              ss << std::endl << "remaining keys: ";
                              for ( auto &k : next )
                                  ss << k << ", ";
                              throw std::runtime_error( ss.str() );
                          } );
    }

  private:

    template< typename Fail >
    void extractValue( std::string &str, lyaml::Node *node, Fail fail )
    {
        auto *scalar = dyn_cast< lyaml::ScalarNode >( node );
        if ( !scalar )
            return fail( str, "YAML error: expected scalar", KeyList{}, KeyList{} );

        ::llvm::SmallVector< char, 128 > storage;
        auto ref = scalar->getValue( storage );
        str = ref.str();
    }

    template< typename T, typename Fail >
    auto extractValue( T &num, lyaml::Node *node, Fail fail )
        -> std::enable_if_t< std::is_arithmetic< T >::value, void >
    {
        auto *scalar = dyn_cast< lyaml::ScalarNode >( node );
        if ( !scalar )
            return fail( num, "YAML error: expected scalar", KeyList{}, KeyList{} );

        ::llvm::SmallVector< char, 128 > storage;
        auto ref = scalar->getValue( storage );

        std::stringstream ss( ref.str() );
        ss >> num;
        if ( ss.fail() )
            return fail( num, "YAML conversion error from " + ref.str(), KeyList{}, KeyList{} );
    }

    template< typename T, typename Fail >
    void extractValue( std::vector< T > &vec, lyaml::Node *node, Fail fail )
    {
        vec.emplace_back();
        extractValue( vec.back(), node, [&]( auto &, auto&&... args ) { fail( vec, args... ); } );
    }

    std::string _data;
};

} // namespace yaml

namespace t_yaml
{

struct TestParse
{
    TEST(simple)
    {
        yaml::Parser y( "key: value\nanother: 2" );
        ASSERT_EQ( y.get< std::string >( { "key" } ), "value" );
        ASSERT_EQ( y.get< int >( { "another" } ), 2 );
    }

    TEST(nested)
    {
        yaml::Parser y( "key:\n  nested: value\n  another: 2" );
        ASSERT_EQ( y.get< std::string >( { "key", "nested" } ), "value" );
        ASSERT_EQ( y.get< int >( { "key", "another" } ), 2 );
    }

    TEST(list)
    {
        yaml::Parser y( "- item 1\n- item 2" );
        auto vec = y.get< std::vector< std::string > >( { "*" } );
        ASSERT_EQ( vec.size(), 2 );
        ASSERT_EQ( vec[ 0 ], "item 1" );
        ASSERT_EQ( vec[ 1 ], "item 2" );
    }

    TEST(nested_list)
    {
        yaml::Parser y( "- [ 1, 2 ] \n- [ 3, 4 ]" );
        auto vec = y.get< std::vector< int > >( { "*", "*" } );
        ASSERT_EQ( vec.size(), 4 );
        ASSERT( vec == decltype( vec ){ 1, 2, 3, 4 } );
    }

    TEST(list_of_maps)
    {
        yaml::Parser y( "- item: 1\n- item: 2" );
        auto vec = y.get< std::vector< int > >( { "*", "item" } );
        ASSERT_EQ( vec.size(), 2 );
        ASSERT_EQ( vec[ 0 ], 1 );
        ASSERT_EQ( vec[ 1 ], 2 );
    }

    TEST(list_of_maps_2)
    {
        yaml::Parser y( "- item: 1\n  foo: 2\n- item: 2\n  foo: 1" );
        auto vec = y.get< std::vector< int > >( { "*", "foo" } );
        ASSERT_EQ( vec.size(), 2 );
        ASSERT_EQ( vec[ 0 ], 2 );
        ASSERT_EQ( vec[ 1 ], 1 );
    }
};

}

} // namespace brick

// vim: syntax=cpp tabstop=4 shiftwidth=4 expandtab ft=cpp
